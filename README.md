## json-to-simple-graphql-schema

Transforms JSON input into a GraphQL schema.
[Try it here](https://walmartlabs.github.io/json-to-simple-graphql-schema/)

### Why would I use this?

Let's say you want to use an existing REST API in a GraphQL service and expose the data that API provides. You'll need to expose that data in a GraphQL schema. Without this tool, you'll have to slog through the JSON response and manually extract and convert the relevant types to GraphQL schema types. This tool attempts to provide an automated reasonable first-pass at that effort.

### Installation:

For use as a command-line app use `npx` :) If you'd really like to install, you can do:

```bash
npm i -g @walmartlabs/json-to-simple-graphql-schema
```

For use in a project:

```bash
npm i @walmartlabs/json-to-simple-graphql-schema
```

### Command Line Usage:

Pipe in some JSON. Here's a cURL JSON response piped in to this app:

```bash
curl "https://data.cityofnewyork.us/api/views/kku6-nxdu/rows.json?accessType=DOWNLOAD" \
| npx @walmartlabs/json-to-simple-graphql-schema
```

> You'll still need to rename the resulting main Type in the schema, unless you like `AutogeneratedMainType` :)

Or pipe in some JSON from a JSON file.

```bash
curl https://data.cityofnewyork.us/api/views/kku6-nxdu/rows.json?accessType=DOWNLOAD > input.json

cat input.json | npx json-to-simple-graphql-schema > output.graphql
```

Optional parameters:

- baseType = "AutogeneratedMainType"
- prefix = ""

```bash
curl https://data.cityofnewyork.us/api/views/kku6-nxdu/rows.json?accessType=DOWNLOAD > input.json

cat input.json | npx json-to-simple-graphql-schema --baseType BaseType --prefix Prefix > output.graphql
```

### Usage in front-end JS:

```javascript
import { jsonToSchema } from "@walmartlabs/json-to-simple-graphql-schema/lib";

const schema = jsonToSchema({ jsonInput: '{"name": "Test"}' });
console.log(schema.value);
```

If you need more guidance, have a look at [the source for our simple web-ui](./web-ui).

### Example output:

Given this JSON:

```json
{
  "id": "some-id-0",
  "name": "A fun object",
  "subType": {
    "id": "some-id-1",
    "name": "A fun sub-type"
  }
}
```

This app will send this to stdout:

```
type SubType {
  id: String
  name: String,
}
type AutogeneratedMainType {
  id: String
  name: String
  subType: SubType
}
```

### Fun features: duplicate removal

Consider this JSON with 2 `color` types:

```json
{
  "id": "some-id-0",
  "name": "A fun object",
  "color": {
    "id": "color-id-1",
    "name": "Test color"
  },
  "subType": {
    "id": "some-id-1",
    "name": "A fun sub-type",
    "color": {
      "id": "color-id-1",
      "name": "Test color",
      "hex": "#ff0000"
    }
  }
}
```

When piped to this app, the following schema is produced:

```
type Color {
  id: String
  name: String
  hex: String,
}
type SubType {
  id: String
  name: String
  color: Color,
}
type AutogeneratedMainType {
  id: String
  name: String
  subType: SubType
  color: Color
}
```

It kept the `Color` type with more fields.

### Fun features: calls out possible duplicates

Consider this JSON with two types containing identical fields:

```json
{
  "id": "some-id-0",
  "name": "A fun object",
  "color": {
    "id": "color-id-1",
    "name": "Test color"
  },
  "favoriteColor": {
    "id": "color-id-1",
    "name": "Test color"
  }
}
```

When piped to this app, the following schema is produced:

```
type FavoriteColor {
  id: String
  name: String
}

type Color {
  id: String
  name: String
}

type AutogeneratedMainType {
  id: String
  name: String
  favoriteColor: FavoriteColor
  color: Color
}

# Types with identical fields:
# FavoriteColor Color
```

It called out the two types with identical fields.
